# C++11 多线程编程示例集

本目录包含了C++11多线程编程的基础示例，从线程的创建、管理到同步机制，循序渐进地展示了C++11多线程编程的核心概念和技术。

C++11 多线程编程核心概念

通过本目录的示例，可以学习到以下C++11多线程编程的核心概念：

1. **线程创建**：使用`std::thread`类创建线程，可以接受多种可调用对象
2. **线程管理**：通过`join()`和`detach()`控制线程的生命周期
3. **并发安全**：使用互斥锁等同步机制保护共享资源
4. **性能对比**：理解多线程在不同场景下的性能优势
5. **线程标识**：通过`std::thread::id`标识线程

## 目录结构及功能说明

### 1. 1.thread/ - 线程创建基础示例

**核心特性**：演示单线程与多线程执行效率对比

**主要内容**：

- `intro.cpp`：单线程版本的奇数偶数求和示例，用于对比
- `thread.cpp`：多线程版本的奇数偶数求和示例，展示了使用`std::thread`创建线程的基本方法

**关键点**：通过对比单线程和多线程版本的执行时间，直观展示了多线程在计算密集型任务上的优势。示例中<font color=Red>使用 `join()`方法等待线程完成</font>，并使用`high_resolution_clock`测量执行时间。

### 2. 2.create_type/ - 线程创建的五种方式

**核心特性**：全面展示C++11中创建线程的各种方法

**主要内容**：

- `1.function_pointer.cpp`：使用函数指针创建线程
- `2.lambda_function.cpp`：使用Lambda函数创建线程
- `3.functor.cpp`：使用函数对象(Functor)创建线程
- `4.no_static_member_function.cpp`：使用非静态成员函数创建线程
- `5.static_member_function.cpp`：使用静态成员函数创建线程

**关键点**：C++11提供了灵活多样的线程创建方式，可以根据具体场景选择最适合的方式。示例展示了每种创建方式的语法和使用场景。

### 3. join_detach/ - 线程的等待与分离

**核心特性**：演示线程的join和detach操作的区别和使用场景

**主要内容**：

- `join.cpp`：展示join操作的使用，主线程等待子线程完成
- `detach.cpp`：展示detach操作的使用，主线程与子线程分离

**关键点**：

- `join()`：<font color=Red>阻塞主线程</font>，直到子线程执行完毕
- `detach()`：将子线程与主线程分离，子线程在后台独立运行
- 演示了`joinable()`方法的使用，避免双重join导致程序崩溃

### 4. mutex/ - 互斥锁与临界区保护

**核心特性**：演示如何使用互斥锁保护共享资源

**错误理解：这3个线程并行运行，最终不论有没有加mutex，结果都是increaseCounter累加3遍吧？**

---

你的理解有偏差。我们来澄清一个关键点：

> ✅ **有没有 `mutex`，`increaseCounter` 函数都会被调用 3 次（每个线程各一次）**，  
> ❌ **但没有 `mutex` 时 `counter` 的最终值不一定等于 `3 × iterations`！**

- ❌ **`counter` 的最终值可能远小于 30（如果没有 mutex）**，因为发生了**数据竞争（Data Race）**。

#### 🧨 为什么？

`++counter` 看似简单，实际是三步操作：

1. 从内存读取 `counter` 的值
2. 加 1
3. 写回内存

**两个线程可能同时读到同一个值**，比如都读到 `5`，然后都加 1，都写回 `6`。  
结果：**两次 `++` 只加了一次！**

| 情况        | `increaseCounter` 调用次数 | `++counter` 执行次数 | `counter` 最终值            |
| --------- | ---------------------- | ---------------- | ------------------------ |
| 有 `mutex` | 3 次                    | 30 次             | ✅ 正确：30                  |
| 无 `mutex` | 3 次                    | 30 次             | ❌ 错误：**小于 30，不确定**（数据竞争） |

> 🔥 所以：**线程数 ≠ 正确结果**。没有同步机制，多线程反而会导致计算错误。

**主要内容**：

- `critical_section.cpp`：使用`std::mutex`保护共享变量`sum`，避免多线程并发访问导致的数据竞争

**关键点**：在多线程环境下，对共享资源的并发访问可能导致数据不一致。示例展示了如何使用互斥锁的`lock()`和`unlock()`方法来确保在同一时间只有一个线程能够访问共享资源。

## 
